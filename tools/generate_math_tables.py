#!/usr/bin/env python3
"""
=============================================================================
ARDK - Math Table Generator
=============================================================================

Generates sin, cos, and atan2 lookup tables for retro platforms.

Output formats:
  - C arrays (.c/.h files)
  - Assembly data (.asm/.inc files)

Usage:
  python generate_math_tables.py -o src/hal/math_tables.c
  python generate_math_tables.py -o src/hal/math_tables.asm --format asm
  python generate_math_tables.py --platform nes -o src/hal/nes/

Tables generated:
  - sin_table[256]: Sine values for angles 0-255 (256 = full circle)
  - cos_table[256]: Cosine values (same as sin, offset by 64)
  - atan2_table[256]: Arctangent lookup for first octant

All values are 8.8 fixed-point (signed i16 for sin/cos, u8 for angle).
"""

import argparse
import math
import os
from pathlib import Path


def generate_sin_table():
    """
    Generate 256-entry sine table.

    Angle system: 0-255 = full circle (256 = 360°)
    Output: fixed8_8 values in range [-256, 256] (-1.0 to 1.0)

    Returns list of signed 16-bit integers.
    """
    table = []
    for i in range(256):
        # Convert from 256-angle to radians
        angle_rad = (i / 256.0) * 2.0 * math.pi
        # Sin value in [-1, 1], scale to [-256, 256]
        sin_val = math.sin(angle_rad) * 256.0
        # Round to integer
        table.append(int(round(sin_val)))
    return table


def generate_cos_table():
    """
    Generate 256-entry cosine table.
    Same as sin, but offset by 64 (90°).
    """
    table = []
    for i in range(256):
        angle_rad = (i / 256.0) * 2.0 * math.pi
        cos_val = math.cos(angle_rad) * 256.0
        table.append(int(round(cos_val)))
    return table


def generate_atan2_table(size=256):
    """
    Generate atan2 lookup table for first octant.

    For full atan2, we only need to store values for the first octant
    (where dx >= dy >= 0). Other octants are derived by mirroring.

    Index: (dy * size) / dx (scaled ratio)
    Output: angle in 0-255 system for first octant (0-32)

    Returns list of unsigned 8-bit angles.
    """
    table = []
    for i in range(size):
        # i represents dy/dx ratio from 0 to 1 (mapped to 0 to size-1)
        ratio = i / (size - 1) if size > 1 else 0
        # atan gives angle in radians for ratio (0 to π/4 for first octant)
        angle_rad = math.atan(ratio)
        # Convert to 256-angle system (π/4 rad = 32 in 256-system)
        angle_256 = (angle_rad / (2.0 * math.pi)) * 256.0
        table.append(int(round(angle_256)))
    return table


def format_c_array(name, values, signed=True, per_line=16):
    """Format values as a C array."""
    dtype = "i16" if signed else "u8"
    lines = [f"const {dtype} {name}[{len(values)}] = {{"]

    for i in range(0, len(values), per_line):
        chunk = values[i:i+per_line]
        if signed:
            line = "    " + ", ".join(f"{v:4d}" for v in chunk)
        else:
            line = "    " + ", ".join(f"0x{v:02X}" for v in chunk)
        if i + per_line < len(values):
            line += ","
        lines.append(line)

    lines.append("};")
    return "\n".join(lines)


def format_asm_array(name, values, signed=True, per_line=16):
    """Format values as assembly data."""
    lines = [f"{name}:"]

    for i in range(0, len(values), per_line):
        chunk = values[i:i+per_line]
        if signed:
            # 16-bit words for signed values
            line = "    .word " + ", ".join(f"{v}" for v in chunk)
        else:
            # 8-bit bytes for unsigned
            line = "    .byte " + ", ".join(f"${v:02X}" for v in chunk)
        lines.append(line)

    return "\n".join(lines)


def generate_c_output(sin_table, cos_table, atan2_table):
    """Generate complete C source file."""
    header = '''\
/*
 * =============================================================================
 * ARDK - Math Lookup Tables (Auto-generated)
 * =============================================================================
 *
 * DO NOT EDIT - Generated by generate_math_tables.py
 *
 * Tables:
 *   sin_table[256]   - Sine values, fixed8_8 range [-256, 256]
 *   cos_table[256]   - Cosine values, fixed8_8 range [-256, 256]
 *   atan2_table[256] - First octant atan2, angle range [0, 32]
 *
 * Angle system: 0-255 = full circle
 *   0 = right (positive X)
 *   64 = down (positive Y)
 *   128 = left (negative X)
 *   192 = up (negative Y)
 * =============================================================================
 */

#include "../hal.h"

/* Define this to prevent hal_common.c from using stub implementations */
#define HAL_MATH_TABLES_PROVIDED

'''

    sin_array = format_c_array("sin_table", sin_table, signed=True)
    cos_array = format_c_array("cos_table", cos_table, signed=True)
    atan_array = format_c_array("atan2_table", atan2_table, signed=False)

    impl = '''

/* ===========================================================================
 * Table-based implementations
 * =========================================================================== */

fixed8_8 hal_sin(angle_t angle) {
    return sin_table[angle];
}

fixed8_8 hal_cos(angle_t angle) {
    return cos_table[angle];
}

/*
 * Full atan2 using first-octant table with mirroring.
 */
angle_t hal_atan2(fixed8_8 dy, fixed8_8 dx) {
    /* Handle zero case */
    if (dx == 0 && dy == 0) return 0;

    /* Get absolute values and track signs */
    fixed8_8 adx = (dx < 0) ? -dx : dx;
    fixed8_8 ady = (dy < 0) ? -dy : dy;
    u8 swap = 0;
    u8 negate_x = (dx < 0) ? 1 : 0;
    u8 negate_y = (dy < 0) ? 1 : 0;

    /* Ensure we're in first octant (adx >= ady) */
    if (ady > adx) {
        fixed8_8 tmp = adx;
        adx = ady;
        ady = tmp;
        swap = 1;
    }

    /* Calculate table index: (ady * 255) / adx */
    u8 index;
    if (adx == 0) {
        index = 0;
    } else {
        index = (u8)(((u32)ady * 255) / adx);
    }

    /* Look up angle in first octant (0-32) */
    angle_t angle = atan2_table[index];

    /* Mirror for second octant */
    if (swap) {
        angle = 64 - angle;
    }

    /* Mirror for other quadrants */
    if (negate_x) {
        angle = 128 - angle;
    }
    if (negate_y) {
        angle = 256 - angle;
    }

    return angle;
}
'''

    return header + sin_array + "\n\n" + cos_array + "\n\n" + atan_array + impl


def generate_c_header():
    """Generate C header file."""
    return '''\
/*
 * =============================================================================
 * ARDK - Math Lookup Tables Header (Auto-generated)
 * =============================================================================
 */

#ifndef ARDK_MATH_TABLES_H
#define ARDK_MATH_TABLES_H

#include "../types.h"

/* Lookup tables */
extern const i16 sin_table[256];
extern const i16 cos_table[256];
extern const u8 atan2_table[256];

#endif /* ARDK_MATH_TABLES_H */
'''


def generate_asm_output(sin_table, cos_table, atan2_table, platform="nes"):
    """Generate assembly file for specified platform."""

    if platform == "nes":
        header = '''\
; =============================================================================
; ARDK - Math Lookup Tables (Auto-generated for NES/6502)
; =============================================================================
;
; DO NOT EDIT - Generated by generate_math_tables.py
;
; Tables:
;   sin_table   - 256 words, sine values (fixed8_8)
;   cos_table   - 256 words, cosine values (fixed8_8)
;   atan2_table - 256 bytes, first octant atan2
;
; Usage (ca65):
;   .include "math_tables.inc"
;   ldy angle
;   lda sin_table_lo, y
;   ldx sin_table_hi, y
;
; =============================================================================

.segment "RODATA"

'''
        # For 6502, split 16-bit tables into low/high bytes for easier access
        sin_lo = [v & 0xFF for v in sin_table]
        sin_hi = [(v >> 8) & 0xFF if v >= 0 else ((v + 65536) >> 8) & 0xFF for v in sin_table]
        cos_lo = [v & 0xFF for v in cos_table]
        cos_hi = [(v >> 8) & 0xFF if v >= 0 else ((v + 65536) >> 8) & 0xFF for v in cos_table]

        sin_lo_asm = format_asm_array("sin_table_lo", sin_lo, signed=False)
        sin_hi_asm = format_asm_array("sin_table_hi", sin_hi, signed=False)
        cos_lo_asm = format_asm_array("cos_table_lo", cos_lo, signed=False)
        cos_hi_asm = format_asm_array("cos_table_hi", cos_hi, signed=False)
        atan_asm = format_asm_array("atan2_table", atan2_table, signed=False)

        return header + sin_lo_asm + "\n\n" + sin_hi_asm + "\n\n" + \
               cos_lo_asm + "\n\n" + cos_hi_asm + "\n\n" + atan_asm

    elif platform == "genesis":
        header = '''\
; =============================================================================
; ARDK - Math Lookup Tables (Auto-generated for Genesis/68000)
; =============================================================================
;
; DO NOT EDIT - Generated by generate_math_tables.py
;
; 68000 can handle 16-bit lookups directly.
;
; =============================================================================

    .section .rodata

'''
        sin_asm = format_asm_array("sin_table", sin_table, signed=True)
        cos_asm = format_asm_array("cos_table", cos_table, signed=True)
        atan_asm = format_asm_array("atan2_table", atan2_table, signed=False)

        return header + sin_asm + "\n\n" + cos_asm + "\n\n" + atan_asm

    else:
        raise ValueError(f"Unknown platform: {platform}")


def main():
    parser = argparse.ArgumentParser(
        description="Generate math lookup tables for ARDK"
    )
    parser.add_argument(
        "-o", "--output",
        default="math_tables.c",
        help="Output file path (or directory if multiple files)"
    )
    parser.add_argument(
        "--format",
        choices=["c", "asm", "both"],
        default="c",
        help="Output format"
    )
    parser.add_argument(
        "--platform",
        choices=["nes", "genesis", "gba"],
        default="nes",
        help="Target platform (for asm output)"
    )

    args = parser.parse_args()

    # Generate tables
    print("Generating sin table (256 entries)...")
    sin_table = generate_sin_table()

    print("Generating cos table (256 entries)...")
    cos_table = generate_cos_table()

    print("Generating atan2 table (256 entries)...")
    atan2_table = generate_atan2_table(256)

    # Determine output path(s)
    output_path = Path(args.output)

    if args.format == "c" or args.format == "both":
        if output_path.is_dir():
            c_path = output_path / "math_tables.c"
            h_path = output_path / "math_tables.h"
        else:
            c_path = output_path
            h_path = output_path.with_suffix(".h")

        print(f"Writing C source to {c_path}")
        c_content = generate_c_output(sin_table, cos_table, atan2_table)
        c_path.write_text(c_content)

        print(f"Writing C header to {h_path}")
        h_content = generate_c_header()
        h_path.write_text(h_content)

    if args.format == "asm" or args.format == "both":
        if output_path.is_dir():
            asm_path = output_path / f"math_tables_{args.platform}.asm"
        else:
            asm_path = output_path.with_suffix(".asm")

        print(f"Writing {args.platform} assembly to {asm_path}")
        asm_content = generate_asm_output(sin_table, cos_table, atan2_table, args.platform)
        asm_path.write_text(asm_content)

    print("Done!")

    # Print some verification values
    print("\nVerification (sin values at key angles):")
    print(f"  sin(0°)   = sin_table[0]   = {sin_table[0]:4d} (expected: 0)")
    print(f"  sin(90°)  = sin_table[64]  = {sin_table[64]:4d} (expected: 256)")
    print(f"  sin(180°) = sin_table[128] = {sin_table[128]:4d} (expected: 0)")
    print(f"  sin(270°) = sin_table[192] = {sin_table[192]:4d} (expected: -256)")


if __name__ == "__main__":
    main()
