#!/usr/bin/env python3
"""
AI Level Design Assistant for NES Development

Helps with level design by:
1. Analyzing level images and suggesting metatile layouts
2. Generating level data from sketches/mockups
3. Suggesting enemy placement based on difficulty curves
4. Validating level constraints (screen size, tile limits)
5. Auto-generating collision maps

Uses Gemini AI vision for intelligent level analysis.

Usage:
    python tools/ai_level_assistant.py level_mockup.png --output levels/level1.asm
    python tools/ai_level_assistant.py --generate "underground cave with platforms"
"""

import os
import sys
import json
import argparse
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict, Any, Tuple, Optional

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

try:
    from google import genai
    from google.genai import types
    HAS_GEMINI = True
except ImportError:
    HAS_GEMINI = False

# NES Level Constraints
NES_SCREEN_WIDTH = 256           # Pixels
NES_SCREEN_HEIGHT = 240          # Pixels (224 visible on most TVs)
NES_TILE_SIZE = 8                # 8x8 tiles
NES_METATILE_SIZE = 16           # 16x16 common metatile
NES_TILES_PER_SCREEN_W = 32      # 256 / 8
NES_TILES_PER_SCREEN_H = 30      # 240 / 8
NES_METATILES_PER_SCREEN_W = 16  # 256 / 16
NES_METATILES_PER_SCREEN_H = 15  # 240 / 16

# Common metatile types
METATILE_TYPES = {
    'empty': 0x00,
    'solid': 0x01,
    'platform': 0x02,
    'hazard': 0x03,
    'ladder': 0x04,
    'water': 0x05,
    'breakable': 0x06,
    'slope_left': 0x07,
    'slope_right': 0x08,
    'door': 0x09,
    'spawn_point': 0x0A,
    'checkpoint': 0x0B,
}

@dataclass
class LevelElement:
    """A single element in the level"""
    type: str
    x: int                       # Position in metatiles
    y: int
    width: int = 1               # Size in metatiles
    height: int = 1
    properties: Dict[str, Any] = field(default_factory=dict)

@dataclass
class EnemySpawn:
    """Enemy spawn point"""
    enemy_type: str
    x: int                       # Pixel position
    y: int
    facing: str = 'left'         # left, right
    behavior: str = 'patrol'     # patrol, chase, stationary
    difficulty: int = 1          # 1-10

@dataclass
class LevelData:
    """Complete level data structure"""
    name: str
    width_screens: int           # Level width in screens
    height_screens: int          # Level height in screens (usually 1)

    # Metatile grid
    metatile_grid: List[List[int]] = field(default_factory=list)

    # Elements and spawns
    elements: List[LevelElement] = field(default_factory=list)
    enemy_spawns: List[EnemySpawn] = field(default_factory=list)

    # Metadata
    theme: str = ""              # cave, forest, castle, etc.
    difficulty: str = "normal"   # easy, normal, hard
    music_track: str = ""

    # Player start
    player_start_x: int = 16
    player_start_y: int = 200

    def to_assembly(self) -> str:
        """Generate assembly data for the level"""
        lines = [
            f"; =============================================================================",
            f"; Level: {self.name}",
            f"; Theme: {self.theme}",
            f"; Difficulty: {self.difficulty}",
            f"; Size: {self.width_screens}x{self.height_screens} screens",
            f"; Auto-generated by AI Level Assistant",
            f"; =============================================================================",
            "",
            f".segment \"RODATA\"",
            "",
            f"; Level metadata",
            f"level_{self.name.lower()}_width:",
            f"    .byte {self.width_screens}",
            f"level_{self.name.lower()}_height:",
            f"    .byte {self.height_screens}",
            f"level_{self.name.lower()}_start_x:",
            f"    .byte {self.player_start_x}",
            f"level_{self.name.lower()}_start_y:",
            f"    .byte {self.player_start_y}",
            "",
        ]

        # Metatile data
        lines.append(f"; Metatile data ({len(self.metatile_grid)} rows)")
        lines.append(f"level_{self.name.lower()}_data:")

        for row_idx, row in enumerate(self.metatile_grid):
            row_hex = ', '.join(f'${m:02X}' for m in row)
            lines.append(f"    .byte {row_hex}  ; Row {row_idx}")

        lines.append("")

        # Enemy spawns
        if self.enemy_spawns:
            lines.append(f"; Enemy spawns ({len(self.enemy_spawns)} enemies)")
            lines.append(f"level_{self.name.lower()}_enemies:")
            for i, spawn in enumerate(self.enemy_spawns):
                lines.append(f"    ; Enemy {i}: {spawn.enemy_type} at ({spawn.x}, {spawn.y})")
                lines.append(f"    .byte {spawn.x & 0xFF}, {spawn.y & 0xFF}  ; Position")
                lines.append(f"    .byte {hash(spawn.enemy_type) & 0xFF}  ; Type")
                lines.append(f"    .byte {1 if spawn.facing == 'right' else 0}  ; Facing")
            lines.append(f"    .byte $FF  ; End marker")

        lines.append("")
        lines.append(f"; End of level {self.name}")

        return '\n'.join(lines)


class AILevelAssistant:
    """AI-powered level design assistant"""

    def __init__(self, api_key: str = None):
        self.api_key = api_key or os.getenv('GEMINI_API_KEY')
        self.client = None

        if HAS_GEMINI and self.api_key:
            self.client = genai.Client(api_key=self.api_key)

    def analyze_level_image(self, image_path: str) -> LevelData:
        """Analyze a level mockup/sketch image"""

        if not HAS_PIL:
            raise RuntimeError("PIL/Pillow required for image analysis")

        img = Image.open(image_path)
        width, height = img.size

        # Calculate level size in screens
        screens_w = max(1, (width + NES_SCREEN_WIDTH - 1) // NES_SCREEN_WIDTH)
        screens_h = max(1, (height + NES_SCREEN_HEIGHT - 1) // NES_SCREEN_HEIGHT)

        level = LevelData(
            name=Path(image_path).stem,
            width_screens=screens_w,
            height_screens=screens_h
        )

        # Use AI for intelligent analysis
        if self.client:
            self._ai_analyze_level(level, image_path, img)
        else:
            # Basic color-based analysis
            self._basic_analyze_level(level, img)

        return level

    def _ai_analyze_level(self, level: LevelData, image_path: str, img: Image.Image):
        """Use AI to analyze level structure"""

        # Resize for API
        max_size = 1024
        if max(img.size) > max_size:
            ratio = max_size / max(img.size)
            new_size = (int(img.width * ratio), int(img.height * ratio))
            img = img.resize(new_size, Image.Resampling.LANCZOS)

        # Convert to bytes
        import io
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        image_bytes = buffer.getvalue()

        prompt = """Analyze this level mockup/sketch for a NES-style platformer game.

The NES screen is 256x240 pixels, using 16x16 metatiles (16 wide x 15 tall per screen).

Identify and describe:

1. **Theme**: What type of environment is this? (cave, forest, castle, underwater, etc.)

2. **Platforms**: Identify platform locations. For each platform, give:
   - Approximate position (x, y in metatile units, 0-15 for x, 0-14 for y)
   - Width in metatiles
   - Type (solid, moving, crumbling, etc.)

3. **Hazards**: Identify dangers (spikes, lava, pits)
   - Position and size

4. **Key Elements**: Identify special elements:
   - Player start position
   - Goal/exit location
   - Collectibles
   - Checkpoints

5. **Enemy Placement Suggestions**: Based on the layout, suggest:
   - Good spots for enemies
   - Enemy types that would fit
   - Patrol routes

6. **Difficulty Assessment**: Rate the apparent difficulty (1-10)

Return JSON:
{
    "theme": "cave",
    "difficulty": 5,
    "player_start": {"x": 1, "y": 12},
    "goal": {"x": 14, "y": 5},
    "platforms": [
        {"x": 0, "y": 13, "width": 16, "height": 2, "type": "solid"},
        {"x": 3, "y": 10, "width": 4, "height": 1, "type": "platform"}
    ],
    "hazards": [
        {"x": 6, "y": 13, "width": 2, "type": "spikes"}
    ],
    "enemies": [
        {"x": 100, "y": 180, "type": "walker", "behavior": "patrol"}
    ],
    "notes": "Vertical platforming section with tight jumps"
}"""

        try:
            image_part = types.Part.from_bytes(data=image_bytes, mime_type='image/png')

            response = self.client.models.generate_content(
                model='gemini-2.5-flash',
                contents=[prompt, image_part]
            )

            text = response.text

            # Extract JSON
            if '```json' in text:
                text = text.split('```json')[1].split('```')[0]
            elif '```' in text:
                text = text.split('```')[1].split('```')[0]

            data = json.loads(text.strip())

            # Populate level data
            level.theme = data.get('theme', 'unknown')
            level.difficulty = str(data.get('difficulty', 'normal'))

            if data.get('player_start'):
                level.player_start_x = data['player_start']['x'] * 16
                level.player_start_y = data['player_start']['y'] * 16

            # Build metatile grid from platforms
            grid_h = NES_METATILES_PER_SCREEN_H * level.height_screens
            grid_w = NES_METATILES_PER_SCREEN_W * level.width_screens
            level.metatile_grid = [[METATILE_TYPES['empty']] * grid_w for _ in range(grid_h)]

            # Place platforms
            for plat in data.get('platforms', []):
                x, y = plat['x'], plat['y']
                w = plat.get('width', 1)
                h = plat.get('height', 1)
                tile_type = METATILE_TYPES.get(plat.get('type', 'solid'), METATILE_TYPES['solid'])

                for dy in range(h):
                    for dx in range(w):
                        if 0 <= y + dy < grid_h and 0 <= x + dx < grid_w:
                            level.metatile_grid[y + dy][x + dx] = tile_type

            # Place hazards
            for hazard in data.get('hazards', []):
                x, y = hazard['x'], hazard['y']
                w = hazard.get('width', 1)
                for dx in range(w):
                    if 0 <= y < grid_h and 0 <= x + dx < grid_w:
                        level.metatile_grid[y][x + dx] = METATILE_TYPES['hazard']

            # Add enemy spawns
            for enemy in data.get('enemies', []):
                spawn = EnemySpawn(
                    enemy_type=enemy.get('type', 'basic'),
                    x=enemy.get('x', 0),
                    y=enemy.get('y', 0),
                    behavior=enemy.get('behavior', 'patrol')
                )
                level.enemy_spawns.append(spawn)

        except Exception as e:
            print(f"AI analysis failed: {e}")
            self._basic_analyze_level(level, img)

    def _basic_analyze_level(self, level: LevelData, img: Image.Image):
        """Basic color-based level analysis (no AI)"""

        # Simple: dark colors = solid, light = empty
        img_rgb = img.convert('RGB')

        grid_h = NES_METATILES_PER_SCREEN_H * level.height_screens
        grid_w = NES_METATILES_PER_SCREEN_W * level.width_screens

        level.metatile_grid = []

        metatile_w = img.width / grid_w
        metatile_h = img.height / grid_h

        for my in range(grid_h):
            row = []
            for mx in range(grid_w):
                # Sample center of metatile
                px = int((mx + 0.5) * metatile_w)
                py = int((my + 0.5) * metatile_h)

                if 0 <= px < img.width and 0 <= py < img.height:
                    r, g, b = img_rgb.getpixel((px, py))
                    brightness = (r + g + b) / 3

                    if brightness < 64:
                        row.append(METATILE_TYPES['solid'])
                    elif brightness < 128:
                        row.append(METATILE_TYPES['platform'])
                    else:
                        row.append(METATILE_TYPES['empty'])
                else:
                    row.append(METATILE_TYPES['empty'])

            level.metatile_grid.append(row)

    def generate_level_from_description(self, description: str,
                                         width_screens: int = 1) -> LevelData:
        """Generate a level from a text description"""

        level = LevelData(
            name="generated",
            width_screens=width_screens,
            height_screens=1
        )

        if self.client:
            self._ai_generate_level(level, description)
        else:
            self._template_generate_level(level, description)

        return level

    def _ai_generate_level(self, level: LevelData, description: str):
        """Use AI to generate level from description"""

        grid_w = NES_METATILES_PER_SCREEN_W * level.width_screens
        grid_h = NES_METATILES_PER_SCREEN_H

        prompt = f"""Design a NES platformer level based on this description:

"{description}"

The level is {grid_w} metatiles wide and {grid_h} metatiles tall.
Metatile coordinates: X from 0 to {grid_w-1}, Y from 0 to {grid_h-1}.
Y=0 is TOP, Y={grid_h-1} is BOTTOM.

Design a playable level with:
1. Ground/floor (usually at Y=13-14)
2. Platforms at varying heights
3. At least one interesting challenge (gap to jump, hazard to avoid)
4. Player start (left side) and goal (right side)

Use these metatile types:
- 0x00: empty (air)
- 0x01: solid (ground, walls)
- 0x02: platform (can jump through from below)
- 0x03: hazard (spikes, lava)
- 0x04: ladder

Return a JSON array representing the level grid, {grid_h} rows of {grid_w} values each.
Also include enemy placements and metadata.

{{
    "theme": "...",
    "grid": [
        [0, 0, 0, ...],  // Row 0 (top)
        [0, 0, 0, ...],  // Row 1
        ...
        [1, 1, 1, ...]   // Row {grid_h-1} (bottom)
    ],
    "enemies": [
        {{"x": 100, "y": 180, "type": "walker"}}
    ],
    "player_start": {{"x": 16, "y": 180}},
    "notes": "..."
}}"""

        try:
            response = self.client.models.generate_content(
                model='gemini-2.5-flash',
                contents=[prompt]
            )

            text = response.text

            if '```json' in text:
                text = text.split('```json')[1].split('```')[0]
            elif '```' in text:
                text = text.split('```')[1].split('```')[0]

            data = json.loads(text.strip())

            level.theme = data.get('theme', 'generated')
            level.metatile_grid = data.get('grid', [])

            # Validate grid size
            if len(level.metatile_grid) != grid_h:
                print(f"Warning: Grid height mismatch ({len(level.metatile_grid)} vs {grid_h})")

            for row in level.metatile_grid:
                if len(row) != grid_w:
                    print(f"Warning: Grid width mismatch ({len(row)} vs {grid_w})")

            if data.get('player_start'):
                level.player_start_x = data['player_start']['x']
                level.player_start_y = data['player_start']['y']

            for enemy in data.get('enemies', []):
                spawn = EnemySpawn(
                    enemy_type=enemy.get('type', 'basic'),
                    x=enemy.get('x', 0),
                    y=enemy.get('y', 0)
                )
                level.enemy_spawns.append(spawn)

        except Exception as e:
            print(f"AI generation failed: {e}")
            self._template_generate_level(level, description)

    def _template_generate_level(self, level: LevelData, description: str):
        """Generate basic level from templates (no AI)"""

        grid_w = NES_METATILES_PER_SCREEN_W * level.width_screens
        grid_h = NES_METATILES_PER_SCREEN_H

        # Initialize with empty
        level.metatile_grid = [[0] * grid_w for _ in range(grid_h)]

        # Add ground
        for x in range(grid_w):
            level.metatile_grid[grid_h - 2][x] = METATILE_TYPES['solid']
            level.metatile_grid[grid_h - 1][x] = METATILE_TYPES['solid']

        # Add some platforms based on description keywords
        desc_lower = description.lower()

        if 'cave' in desc_lower or 'underground' in desc_lower:
            level.theme = 'cave'
            # Add ceiling
            for x in range(grid_w):
                level.metatile_grid[0][x] = METATILE_TYPES['solid']
                level.metatile_grid[1][x] = METATILE_TYPES['solid']

        if 'platform' in desc_lower:
            # Add floating platforms
            level.metatile_grid[8][3] = METATILE_TYPES['platform']
            level.metatile_grid[8][4] = METATILE_TYPES['platform']
            level.metatile_grid[8][5] = METATILE_TYPES['platform']

            level.metatile_grid[6][8] = METATILE_TYPES['platform']
            level.metatile_grid[6][9] = METATILE_TYPES['platform']
            level.metatile_grid[6][10] = METATILE_TYPES['platform']

        if 'hazard' in desc_lower or 'spike' in desc_lower:
            # Add hazards
            level.metatile_grid[grid_h - 3][6] = METATILE_TYPES['hazard']
            level.metatile_grid[grid_h - 3][7] = METATILE_TYPES['hazard']

        level.player_start_x = 24
        level.player_start_y = (grid_h - 3) * 16

    def validate_level(self, level: LevelData) -> List[str]:
        """Validate level for NES constraints"""

        issues = []

        # Check grid dimensions
        expected_h = NES_METATILES_PER_SCREEN_H * level.height_screens
        expected_w = NES_METATILES_PER_SCREEN_W * level.width_screens

        if len(level.metatile_grid) != expected_h:
            issues.append(f"Grid height {len(level.metatile_grid)} != expected {expected_h}")

        for i, row in enumerate(level.metatile_grid):
            if len(row) != expected_w:
                issues.append(f"Row {i} width {len(row)} != expected {expected_w}")

        # Check player start is valid
        start_mx = level.player_start_x // 16
        start_my = level.player_start_y // 16

        if start_my < len(level.metatile_grid):
            if level.metatile_grid[start_my][start_mx] == METATILE_TYPES['solid']:
                issues.append(f"Player starts inside solid tile at ({start_mx}, {start_my})")

        # Check for reachability (basic)
        # (Full reachability analysis would require pathfinding)

        # Check enemy spawns
        for i, spawn in enumerate(level.enemy_spawns):
            if spawn.x < 0 or spawn.x >= expected_w * 16:
                issues.append(f"Enemy {i} X position {spawn.x} out of bounds")
            if spawn.y < 0 or spawn.y >= expected_h * 16:
                issues.append(f"Enemy {i} Y position {spawn.y} out of bounds")

        return issues


def main():
    parser = argparse.ArgumentParser(description='AI Level Design Assistant')
    parser.add_argument('input', nargs='?', help='Level image to analyze')
    parser.add_argument('--generate', '-g', help='Generate level from description')
    parser.add_argument('--output', '-o', help='Output assembly file')
    parser.add_argument('--width', type=int, default=1, help='Level width in screens')
    parser.add_argument('--validate', action='store_true', help='Validate level only')

    args = parser.parse_args()

    api_key = os.getenv('GEMINI_API_KEY')
    assistant = AILevelAssistant(api_key)

    if not api_key:
        print("Note: GEMINI_API_KEY not set. Using basic analysis/generation.")
        print()

    level = None

    if args.generate:
        print(f"Generating level from: '{args.generate}'")
        level = assistant.generate_level_from_description(args.generate, args.width)
    elif args.input:
        print(f"Analyzing level image: {args.input}")
        level = assistant.analyze_level_image(args.input)
    else:
        parser.print_help()
        return

    # Validate
    print("\nValidating level...")
    issues = assistant.validate_level(level)
    if issues:
        print("Issues found:")
        for issue in issues:
            print(f"  - {issue}")
    else:
        print("Level is valid!")

    # Output
    print(f"\nLevel: {level.name}")
    print(f"Theme: {level.theme}")
    print(f"Size: {level.width_screens}x{level.height_screens} screens")
    print(f"Player start: ({level.player_start_x}, {level.player_start_y})")
    print(f"Enemies: {len(level.enemy_spawns)}")

    # Show grid preview (text-based)
    print("\nGrid preview:")
    symbols = {0: '.', 1: '#', 2: '=', 3: '^', 4: 'H'}
    for row in level.metatile_grid[:10]:  # First 10 rows
        line = ''.join(symbols.get(t, '?') for t in row[:32])  # First 32 cols
        print(f"  {line}")
    if len(level.metatile_grid) > 10:
        print("  ...")

    # Save output
    if args.output:
        asm_code = level.to_assembly()
        with open(args.output, 'w') as f:
            f.write(asm_code)
        print(f"\nSaved to: {args.output}")

    print("\nDone!")


if __name__ == '__main__':
    main()
